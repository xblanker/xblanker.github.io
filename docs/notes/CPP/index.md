# CPP

## 核心语言

### Reference 和 Pointer

| 特性            | 指针 (Pointer)  C & C++                                      | 引用 (Reference) C++                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**        | 一个变量，存储的是另一个变量的内存地址。                     | 一个**别名 (alias)**，是目标变量的另一个名字。它不占用独立的内存空间（或编译器在底层实现上会隐藏其内存占用）。 |
| **空值 (Null)** | 可以是 `NULL` 或 `nullptr`，表示不指向任何有效的内存地址。   | **必须在声明时初始化**，且不能为 null。它必须始终指向一个有效的对象。 |
| **可重指向**    | 可以在其生命周期内改变，指向不同的变量。                     | 一旦初始化后，就**不能改变**其指向的变量。它终生绑定到最初的那个对象。 |
| **操作**        | 需要使用 `*` (解引用) 来访问其指向的对象，使用 `&` (取地址) 来获取一个变量的地址。 | 像普通变量一样直接使用，无需任何特殊操作符。编译器会自动处理。 |
| **内存操作**    | 支持复杂的指针算术运算，例如 `p++` 可以移动到下一个内存单元（取决于指针类型）。 | 不支持算术运算。对引用进行 `++` 操作，实际上是作用于它所引用的原始变量。 |
| **用途**        | 传统的 C 风格编程、底层内存操作、动态内存分配 (`malloc`/`free`)、表示可选参数（通过传入`NULL`）。 | 主要用于函数参数（尤其是传递大型对象以避免拷贝开销）和返回值，以及在运算符重载中。让代码更简洁、更安全。 |

**示例:**

```c++
// Pointer
int a = 10;
int* ptr = &a; // ptr 存储 a 的地址
*ptr = 20;     // 通过指针修改 a 的值, a 现在是 20
int b = 30;
ptr = &b;      // 指针可以重新指向 b

// Reference
int x = 10;
int& ref = x;  // ref 是 x 的别名，必须在声明时初始化
ref = 20;      // 修改 ref 就是修改 x
// int& ref2;  // 报错，引用必须被初始化
int y = 30;
ref = y;   // 而是把 y 的值赋给 ref
```

### 函数/运算符重载 (Function/Operator Overloading)

- **C 语言:**
  - **不允许**存在同名的函数。如果你需要一个处理 `int` 和 `double` 的加法函数，你必须为它们起不同的名字，例如 `add_int()` 和 `add_double()`。
  - 运算符（如 `+`, `-`, `*`, `/`）的行为是固定的，不能被改变。
- **C++ 语言:**
  - **函数重载 (Function Overloading):** 允许在同一个作用域内定义多个同名函数，只要它们的**参数列表不同**（参数个数、类型或顺序不同）。编译器会根据你调用时传入的参数来自动选择正确的函数版本。
  - **运算符重载 (Operator Overloading):** 允许你为自定义的类（`class` 或 `struct`）重新定义标准运算符的行为。实现：`ReturnType operator op (prama);`

**示例:**

```c++
void print(int a) {
    std::cout << a << std::endl;
}

void print(double b) {
    std::cout << b << std::endl;
}

struct Vector2D {
    float x, y;

    Vector2D operator+(const Vector2D& other) const {
        return {x + other.x, y + other.y};
    }
};

int main() {
    print(10);      // 调用 print(int)
    print(3.14);    // 调用 print(double)

    Vector2D v1 = {1.0, 2.0};
    Vector2D v2 = {3.0, 4.0};
    Vector2D v3 = v1 + v2; // {4.0, 6.0}
    return 0;
}
```

### 命名空间 (Namespace)

用于解决大型项目中可能出现的“命名冲突”问题。

- **C 语言:**
  - **没有命名空间**的概念。所有的全局变量、函数名等都位于同一个全局作用域中。
  - C 项目通常采用添加前缀的方式来避免命名冲突。例如，一个图形库里的函数可能会被命名为 `gfx_draw_line()`，数据库相关的函数可能叫 `db_connect()`。
- **C++:**
  - 引入了 `namespace` 关键字，可以创建一个具名的作用域，将相关的类、函数、变量等包裹在里面。
  - 不同命名空间中的同名实体不会冲突。
  - 通过 `::` (作用域解析运算符) 来访问特定命名空间中的成员，或者通过 `using` 声明来简化访问。

**示例:**

```c++
namespace MyGraphics {
    void draw() { /* ... */ }
}

namespace MyDatabase {
    void draw() { /* ... */ }
}

int main() {
    MyGraphics::draw(); // 调用图形库的 draw
    MyDatabase::draw(); // 调用数据库的 draw

    // 使用 using 指令
    using namespace MyGraphics;
    draw(); // 相当于 MyGraphics::draw
    return 0;
}
```

### 4. `inline` (内联)

- **C 语言 (C99 标准之前):**
  - `inline` 更多是作为对编译器的**建议**。在 C89 中没有这个关键字。
  - 在头文件中使用 `static inline` 是常见的做法，以确保每个包含该头文件的编译单元都有一份函数的副本，避免链接错误。
- **C 语言 (C99/C11 及之后):**
  - 语义变得更明确。`inline` 函数定义需要在一个地方提供一个外部定义（`extern inline`），以供其他编译单元调用。这使得 `inline` 的行为更加标准化。
- **C++ 语言:**
  - `inline` 的主要目的是**建议**编译器将函数体在调用点展开，以减少函数调用的开销。这对于短小且频繁调用的函数非常有效。
  - 它还有另一个至关重要的作用：**允许多重定义**。如果一个函数（或类的成员函数）定义在头文件中，那么这个头文件可能会被多个 `.cpp` 文件包含。如果没有 `inline`，链接器会报错，因为它在不同的目标文件中看到了同一个函数的多个定义。将函数声明为 `inline` (类定义内部的成员函数默认是 `inline` 的) 告诉链接器，这些重复的定义是允许的，链接时只保留一个即可。

### 构造/析构函数 与 RAII

这是 C++ 面向对象编程与 C 过程式编程在资源管理上的根本区别。

- **C 语言:**
  - **手动管理资源**。程序员需要手动申请资源（如 `malloc` 分配内存，`fopen` 打开文件），并在使用完毕后手动释放（`free` 释放内存，`fclose` 关闭文件）。
  - 这种方式非常容易出错：
    - **忘记释放**：导致内存泄漏、文件句柄耗尽等。
    - **重复释放**：导致程序崩溃。
    - **在函数有多个返回路径（尤其是有错误处理）时，需要在每个退出点都确保资源被释放**，这使得代码冗长且容易出错。
- **C++ 语言:**
  - **构造函数 (Constructor):** 在对象创建时自动被调用，通常用于初始化成员变量、分配资源。
  - **析构函数 (Destructor):** 在对象生命周期结束时（例如，离开作用域、被 `delete`）自动被调用，通常用于释放构造函数中获取的资源。
  - **RAII (Resource Acquisition Is Initialization，资源获取即初始化):** 这是一个核心的 C++ 编程思想。它主张将资源的生命周期与对象的生命周期绑定。资源在对象的构造函数中获取，在析构函数中释放。
  - **优势：**
    - **自动化管理**：程序员不再需要手动调用释放函数，编译器会自动保证在对象销毁时调用析构函数。
    - **异常安全**：即使在函数执行过程中发生异常，栈上的对象也会被“栈展开 (stack unwinding)”机制正确地销毁，其析构函数会被调用，从而保证资源被释放。这是手动管理难以做到的。

**示例:**

```c++
// C
void c_style_file_op() {
    FILE* f = fopen("test.txt", "w");
    if (!f) {
        return;
    }

    if (/* 条件 */) {
        fclose(f); // 释放
        return;
    }

    // pass

    fclose(f); // 释放
}

// C++ RAII
#include <fstream>

void cpp_style_file_op() {
    std::ofstream file("test.txt"); // 构造函数打开文件 (获取资源)

    if (/* 条件 */) {
        // 直接返回，不需要手动关闭文件
        return;
    }

    // pass

} // 函数结束，file 对象离开作用域，其析构函数被自动调用，文件被关闭 (释放资源)
```





































